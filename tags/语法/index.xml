<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语法 on meeting_smile&#39;s blog</title>
    <link>http://localhost:1313/tags/%E8%AF%AD%E6%B3%95/</link>
    <description>Recent content from meeting_smile&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>2054865827@qq.com (meeting_smile)</managingEditor>
    <webMaster>2054865827@qq.com (meeting_smile)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 25 Nov 2025 16:46:00 -0700</lastBuildDate>
    
    
    <atom:link href="http://localhost:1313/tags/%E8%AF%AD%E6%B3%95/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>java基础——线程相关</title>
      <link>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</guid>
      <description>
        <![CDATA[<h1>java基础——线程相关</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java基础线程相关">
<a class="header-anchor" href="#java%e5%9f%ba%e7%a1%80%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%85%b3"></a>
java基础——线程相关
</h1><p><strong>本人在阿里暑期实习单招落榜(2025.6.4)之后，下定决心补全java基础知识时做的笔记</strong></p>
<h2 id="1多线程">
<a class="header-anchor" href="#1%e5%a4%9a%e7%ba%bf%e7%a8%8b"></a>
1.多线程
</h2><h3 id="11-多线程实现的三种方式">
<a class="header-anchor" href="#11-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f"></a>
1.1 多线程实现的三种方式
</h3><h4 id="111-继承thread类">
<a class="header-anchor" href="#111-%e7%bb%a7%e6%89%bfthread%e7%b1%bb"></a>
1.1.1 继承Thread类
</h4><ul>
<li><strong>定义MyThread类，重写run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> getName());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyThread对象</span>
</span></span><span style="display:flex;"><span>        MyThread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        MyThread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现runnable接口">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3"></a>
1.1.2 实现Runnable接口
</h4><ul>
<li><strong>定义MyRunnable接口，实现run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRunnable</span> <span style="color:#66d9ef">implements</span> Runnable{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取到当前执行该方法的Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> t.<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyRunnable对象</span>
</span></span><span style="display:flex;"><span>        MyRunnable myRunnable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyRunnable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用MyRunnable对象创建Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现callable接口可获取线程运行结果">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0callable%e6%8e%a5%e5%8f%a3%e5%8f%af%e8%8e%b7%e5%8f%96%e7%ba%bf%e7%a8%8b%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c"></a>
1.1.2 实现Callable接口（可获取线程运行结果）
</h4><ul>
<li><strong>定义MyCallable类</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCallable</span> <span style="color:#66d9ef">implements</span> Callable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//求1~100的和</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum<span style="color:#f92672">+=</span>i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> ExecutionException, InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyCallable对象</span>
</span></span><span style="display:flex;"><span>        MyCallable myCall <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyCallable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.创建FutureTask对象，用于管理单线程运行的结果</span>
</span></span><span style="display:flex;"><span>        FutureTask<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> ft <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">&lt;&gt;</span>(myCall);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.通过FutureTask对象来创建线程对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(ft);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//4.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//5.利用FutureTask的get()方法获取线程运行的结果</span>
</span></span><span style="display:flex;"><span>        Integer result <span style="color:#f92672">=</span> ft.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(result);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><hr>
<h3 id="12-三种方式的比较">
<a class="header-anchor" href="#12-%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f%e7%9a%84%e6%af%94%e8%be%83"></a>
1.2 三种方式的比较
</h3><table>
  <thead>
      <tr>
          <th>实现方式</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>继承Thread类</td>
          <td>编程比较简单，可以直接使用Thread类中的方法</td>
          <td>扩展性较差，不能再继承其他的类</td>
      </tr>
      <tr>
          <td>实现Runnable接口</td>
          <td>扩展性强，实现该接口的同时还可以继承其他的类</td>
          <td>编程相对复杂，不能直接使用Thread类中的方法</td>
      </tr>
      <tr>
          <td>实现Callable接口</td>
          <td>- 扩展性强（同样可继承其他类）<!-- raw HTML omitted -->- 支持返回值（通过FutureTask获取）<!-- raw HTML omitted -->- 支持抛出检查异常</td>
          <td>- 编程最复杂<!-- raw HTML omitted -->- 需配合ExecutorService使用<!-- raw HTML omitted -->- 不能直接使用Thread类方法</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="13-thread的常见成员方法">
<a class="header-anchor" href="#13-thread%e7%9a%84%e5%b8%b8%e8%a7%81%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95"></a>
1.3 Thread的常见成员方法
</h3><table>
  <thead>
      <tr>
          <th>方法名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>String getName()</code></strong></td>
          <td>返回此线程的名称</td>
      </tr>
      <tr>
          <td><strong><code>void setName(String name)</code></strong></td>
          <td>设置线程的名字（构造方法也可以设置名字）</td>
      </tr>
      <tr>
          <td><strong><code>static Thread currentThread()</code></strong></td>
          <td>获取当前线程的对象</td>
      </tr>
      <tr>
          <td><strong><code>static void sleep(long time)</code></strong></td>
          <td>让线程休眠指定的时间，单位为毫秒</td>
      </tr>
      <tr>
          <td><strong><code>setPriority(int newPriority)</code></strong></td>
          <td>设置线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final int getPriority()</code></strong></td>
          <td>获取线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final void setDaemon(boolean on)</code></strong></td>
          <td>设置为守护线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void yield()</code></strong></td>
          <td>出让线程/礼让线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void join()</code></strong></td>
          <td>插入线程/插队线程</td>
      </tr>
  </tbody>
</table>
<h4 id="131-sleeplong-time">
<a class="header-anchor" href="#131-sleeplong-time"></a>
1.3.1 sleep(long time)
</h4><ul>
<li>
<p><strong>描述：</strong> 让使用当前函数的线程休眠指定时间。</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>数据库</category>
      
    </item>
    
  </channel>
</rss>
