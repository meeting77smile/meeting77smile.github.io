<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>框架 on meeting_smile&#39;s blog</title>
    <link>http://localhost:1313/tags/%E6%A1%86%E6%9E%B6/</link>
    <description>Recent content from meeting_smile&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>2054865827@qq.com (meeting_smile)</managingEditor>
    <webMaster>2054865827@qq.com (meeting_smile)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 25 Nov 2025 16:46:00 -0700</lastBuildDate>
    
    
    <atom:link href="http://localhost:1313/tags/%E6%A1%86%E6%9E%B6/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>Java定时任务的实现</title>
      <link>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 15 Sep 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>
        <![CDATA[<h1>Java定时任务的实现</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java定时任务的实现">
<a class="header-anchor" href="#java%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
Java定时任务的实现
</h1><h2 id="1-scheduled注解">
<a class="header-anchor" href="#1-scheduled%e6%b3%a8%e8%a7%a3"></a>
1. @Scheduled注解
</h2><h3 id="引入依赖">
<a class="header-anchor" href="#%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96"></a>
引入依赖
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- Spring Boot Schedule依赖 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id="使用方法">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95"></a>
使用方法
</h3><ul>
<li>
<p>首先，在定时任务方法所在的类加上 <strong>@Component</strong> 注解</p>
        
        <hr><p>本文2025-09-15首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>@RequestPart与其他注解的区分</title>
      <link>http://localhost:1313/post/@requestpart%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%86/</link>
      <pubDate>Sat, 08 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/@requestpart%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%86/</guid>
      <description>
        <![CDATA[<h1>@RequestPart与其他注解的区分</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="requestpart与其他注解的区分">
<a class="header-anchor" href="#requestpart%e4%b8%8e%e5%85%b6%e4%bb%96%e6%b3%a8%e8%a7%a3%e7%9a%84%e5%8c%ba%e5%88%86"></a>
@RequestPart与其他注解的区分
</h1><h2 id="1--enctype的常见类型">
<a class="header-anchor" href="#1--enctype%e7%9a%84%e5%b8%b8%e8%a7%81%e7%b1%bb%e5%9e%8b"></a>
1.  enctype的常见类型
</h2><p>HTML 表单的 <code>enctype</code>属性主要用于定义表单数据在发送到服务器之前的编码方式，这对于确保数据（尤其是文件）能正确传输至关重要。它主要有以下三种类型：</p>
        
        <hr><p>本文2025-11-08首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>JMH的使用</title>
      <link>http://localhost:1313/post/jmh%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 11 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/jmh%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>
        <![CDATA[<h1>JMH的使用</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="jmh的使用">
<a class="header-anchor" href="#jmh%e7%9a%84%e4%bd%bf%e7%94%a8"></a>
JMH的使用
</h1><h2 id="1-与jmeter的区别">
<a class="header-anchor" href="#1-%e4%b8%8ejmeter%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
1. 与JMeter的区别
</h2><h3 id="11-核心区别和选择">
<a class="header-anchor" href="#11-%e6%a0%b8%e5%bf%83%e5%8c%ba%e5%88%ab%e5%92%8c%e9%80%89%e6%8b%a9"></a>
1.1 核心区别和选择
</h3><table>
  <thead>
      <tr>
          <th>特性</th>
          <th>JMH</th>
          <th>JMeter</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>测试类型</strong></td>
          <td>微基准测试（Microbenchmark）</td>
          <td>负载测试、压力测试（Load/Stress Test）</td>
      </tr>
      <tr>
          <td><strong>测试粒度</strong></td>
          <td>方法级别，代码级</td>
          <td>系统级别，接口/服务级</td>
      </tr>
      <tr>
          <td><strong>测试精度</strong></td>
          <td>毫秒级/微秒级</td>
          <td>秒级</td>
      </tr>
      <tr>
          <td><strong>主要用途</strong></td>
          <td><strong>测试</strong>和<strong>优化</strong>代码片段的性能</td>
          <td>评估系统在高并发下的整体性能</td>
      </tr>
      <tr>
          <td><strong>执行方式</strong></td>
          <td>在JVM内部运行，需要编写Java代码</td>
          <td>从外部模拟用户请求，通过GUI（图形用户界面）配置</td>
      </tr>
      <tr>
          <td><strong>典型问题</strong></td>
          <td>ArrayList和LinkedList的遍历哪个更快</td>
          <td>我的网站能否承受 1000 个用户同时访问？</td>
      </tr>
  </tbody>
</table>
<h3 id="12-核心用途的区别">
<a class="header-anchor" href="#12-%e6%a0%b8%e5%bf%83%e7%94%a8%e9%80%94%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
1.2 核心用途的区别
</h3><ul>
<li>
<p><strong>JMH</strong>：是由 OpenJDK 团队开发的一款专门用于 ​<strong>​Java 代码微基准测试​</strong>​ 的工具，用于测量和比较一小段代码/片段的性能，通过一系列复杂的机制（如预热、多线程隔离等）等手段来<strong>避免JVM的即时编译（JIT）优化、GC垃圾回收等因素对测试结果的干扰</strong>，从而<strong>保证测试结果的精确</strong>。</p>
        
        <hr><p>本文2025-11-11首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
  </channel>
</rss>
