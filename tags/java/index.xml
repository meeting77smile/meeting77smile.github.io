<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on meeting_smile&#39;s blog</title>
    <link>http://localhost:1313/tags/java/</link>
    <description>Recent content from meeting_smile&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>2054865827@qq.com (meeting_smile)</managingEditor>
    <webMaster>2054865827@qq.com (meeting_smile)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 25 Nov 2025 16:46:00 -0700</lastBuildDate>
    
    
    <atom:link href="http://localhost:1313/tags/java/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>使用IDEA的Maven导出jar包失败</title>
      <link>http://localhost:1313/post/%E4%BD%BF%E7%94%A8idea%E7%9A%84maven%E5%AF%BC%E5%87%BAjar%E5%8C%85%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Wed, 09 Jul 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/%E4%BD%BF%E7%94%A8idea%E7%9A%84maven%E5%AF%BC%E5%87%BAjar%E5%8C%85%E5%A4%B1%E8%B4%A5/</guid>
      <description>
        <![CDATA[<h1>使用IDEA的Maven导出jar包失败</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h2 id="使用idea的maven导出jar包失败">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8idea%e7%9a%84maven%e5%af%bc%e5%87%bajar%e5%8c%85%e5%a4%b1%e8%b4%a5"></a>
使用IDEA的Maven导出jar包失败
</h2><ul>
<li>
<p>错误还原：项目使用的是jdk1.8，先使用maven的Lifecycle中的clean，再package，当使用package时，报错：[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project cinema-manage-system: Fatal error compiling: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does</p>
        
        <hr><p>本文2025-07-09首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>开发工具</category>
      
    </item>
    
    

    <item>
      <title>Java定时任务的实现</title>
      <link>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 15 Sep 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>
        <![CDATA[<h1>Java定时任务的实现</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java定时任务的实现">
<a class="header-anchor" href="#java%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
Java定时任务的实现
</h1><h2 id="1-scheduled注解">
<a class="header-anchor" href="#1-scheduled%e6%b3%a8%e8%a7%a3"></a>
1. @Scheduled注解
</h2><h3 id="引入依赖">
<a class="header-anchor" href="#%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96"></a>
引入依赖
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- Spring Boot Schedule依赖 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id="使用方法">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95"></a>
使用方法
</h3><ul>
<li>
<p>首先，在定时任务方法所在的类加上 <strong>@Component</strong> 注解</p>
        
        <hr><p>本文2025-09-15首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>Set和Map的遍历</title>
      <link>http://localhost:1313/post/set%E5%92%8Cmap%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/set%E5%92%8Cmap%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>
        <![CDATA[<h1>Set和Map的遍历</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="set和map的遍历">
<a class="header-anchor" href="#set%e5%92%8cmap%e7%9a%84%e9%81%8d%e5%8e%86"></a>
Set和Map的遍历
</h1><h2 id="1-set的遍历">
<a class="header-anchor" href="#1-set%e7%9a%84%e9%81%8d%e5%8e%86"></a>
1. Set的遍历
</h2><p>遍历set并将其复制给新的数组ret</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ret <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>        Iterator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> set.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>            ret<span style="color:#f92672">[</span>cnt<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();<span style="color:#75715e">//next()：获取下一个值</span>
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="2-map的遍历">
<a class="header-anchor" href="#2-map%e7%9a%84%e9%81%8d%e5%8e%86"></a>
2. Map的遍历
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer,Integer<span style="color:#f92672">&gt;</span> entry : map.<span style="color:#a6e22e">entrySet</span>()) {
</span></span><span style="display:flex;"><span>    ret<span style="color:#f92672">[</span>cnt<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">getValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>java基础——线程相关</title>
      <link>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</guid>
      <description>
        <![CDATA[<h1>java基础——线程相关</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java基础线程相关">
<a class="header-anchor" href="#java%e5%9f%ba%e7%a1%80%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%85%b3"></a>
java基础——线程相关
</h1><p><strong>本人在阿里暑期实习单招落榜(2025.6.4)之后，下定决心补全java基础知识时做的笔记</strong></p>
<h2 id="1多线程">
<a class="header-anchor" href="#1%e5%a4%9a%e7%ba%bf%e7%a8%8b"></a>
1.多线程
</h2><h3 id="11-多线程实现的三种方式">
<a class="header-anchor" href="#11-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f"></a>
1.1 多线程实现的三种方式
</h3><h4 id="111-继承thread类">
<a class="header-anchor" href="#111-%e7%bb%a7%e6%89%bfthread%e7%b1%bb"></a>
1.1.1 继承Thread类
</h4><ul>
<li><strong>定义MyThread类，重写run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> getName());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyThread对象</span>
</span></span><span style="display:flex;"><span>        MyThread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        MyThread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现runnable接口">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3"></a>
1.1.2 实现Runnable接口
</h4><ul>
<li><strong>定义MyRunnable接口，实现run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRunnable</span> <span style="color:#66d9ef">implements</span> Runnable{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取到当前执行该方法的Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> t.<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyRunnable对象</span>
</span></span><span style="display:flex;"><span>        MyRunnable myRunnable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyRunnable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用MyRunnable对象创建Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现callable接口可获取线程运行结果">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0callable%e6%8e%a5%e5%8f%a3%e5%8f%af%e8%8e%b7%e5%8f%96%e7%ba%bf%e7%a8%8b%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c"></a>
1.1.2 实现Callable接口（可获取线程运行结果）
</h4><ul>
<li><strong>定义MyCallable类</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCallable</span> <span style="color:#66d9ef">implements</span> Callable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//求1~100的和</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum<span style="color:#f92672">+=</span>i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> ExecutionException, InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyCallable对象</span>
</span></span><span style="display:flex;"><span>        MyCallable myCall <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyCallable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.创建FutureTask对象，用于管理单线程运行的结果</span>
</span></span><span style="display:flex;"><span>        FutureTask<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> ft <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">&lt;&gt;</span>(myCall);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.通过FutureTask对象来创建线程对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(ft);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//4.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//5.利用FutureTask的get()方法获取线程运行的结果</span>
</span></span><span style="display:flex;"><span>        Integer result <span style="color:#f92672">=</span> ft.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(result);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><hr>
<h3 id="12-三种方式的比较">
<a class="header-anchor" href="#12-%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f%e7%9a%84%e6%af%94%e8%be%83"></a>
1.2 三种方式的比较
</h3><table>
  <thead>
      <tr>
          <th>实现方式</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>继承Thread类</td>
          <td>编程比较简单，可以直接使用Thread类中的方法</td>
          <td>扩展性较差，不能再继承其他的类</td>
      </tr>
      <tr>
          <td>实现Runnable接口</td>
          <td>扩展性强，实现该接口的同时还可以继承其他的类</td>
          <td>编程相对复杂，不能直接使用Thread类中的方法</td>
      </tr>
      <tr>
          <td>实现Callable接口</td>
          <td>- 扩展性强（同样可继承其他类）<!-- raw HTML omitted -->- 支持返回值（通过FutureTask获取）<!-- raw HTML omitted -->- 支持抛出检查异常</td>
          <td>- 编程最复杂<!-- raw HTML omitted -->- 需配合ExecutorService使用<!-- raw HTML omitted -->- 不能直接使用Thread类方法</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="13-thread的常见成员方法">
<a class="header-anchor" href="#13-thread%e7%9a%84%e5%b8%b8%e8%a7%81%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95"></a>
1.3 Thread的常见成员方法
</h3><table>
  <thead>
      <tr>
          <th>方法名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>String getName()</code></strong></td>
          <td>返回此线程的名称</td>
      </tr>
      <tr>
          <td><strong><code>void setName(String name)</code></strong></td>
          <td>设置线程的名字（构造方法也可以设置名字）</td>
      </tr>
      <tr>
          <td><strong><code>static Thread currentThread()</code></strong></td>
          <td>获取当前线程的对象</td>
      </tr>
      <tr>
          <td><strong><code>static void sleep(long time)</code></strong></td>
          <td>让线程休眠指定的时间，单位为毫秒</td>
      </tr>
      <tr>
          <td><strong><code>setPriority(int newPriority)</code></strong></td>
          <td>设置线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final int getPriority()</code></strong></td>
          <td>获取线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final void setDaemon(boolean on)</code></strong></td>
          <td>设置为守护线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void yield()</code></strong></td>
          <td>出让线程/礼让线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void join()</code></strong></td>
          <td>插入线程/插队线程</td>
      </tr>
  </tbody>
</table>
<h4 id="131-sleeplong-time">
<a class="header-anchor" href="#131-sleeplong-time"></a>
1.3.1 sleep(long time)
</h4><ul>
<li>
<p><strong>描述：</strong> 让使用当前函数的线程休眠指定时间。</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>Java的四种引用</title>
      <link>http://localhost:1313/post/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</guid>
      <description>
        <![CDATA[<h1>Java的四种引用</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java的四种引用">
<a class="header-anchor" href="#java%e7%9a%84%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8"></a>
Java的四种引用
</h1><h2 id="1-强引用">
<a class="header-anchor" href="#1-%e5%bc%ba%e5%bc%95%e7%94%a8"></a>
1. 强引用
</h2><h3 id="11-概念">
<a class="header-anchor" href="#11-%e6%a6%82%e5%bf%b5"></a>
1.1 概念
</h3><p>被直接指向的对象实例，即使JVM的堆内存不足爆出OOM错误也不会释放强引用的对象。</p>
<h3 id="12-强引用对象的回收">
<a class="header-anchor" href="#12-%e5%bc%ba%e5%bc%95%e7%94%a8%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9b%9e%e6%94%b6"></a>
1.2 强引用对象的回收
</h3><p>只有当对象无法通过GC Root找到（没有被引用），强引用的对象才可被回收</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>Java 输入输出总结</title>
      <link>http://localhost:1313/post/java-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</guid>
      <description>
        <![CDATA[<h1>Java 输入输出总结</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java-输入输出总结">
<a class="header-anchor" href="#java-%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%80%bb%e7%bb%93"></a>
Java 输入输出总结
</h1><h2 id="scanner中nextnextint和nextline的区别">
<a class="header-anchor" href="#scanner%e4%b8%adnextnextint%e5%92%8cnextline%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
Scanner中，Next()、NextInt()和NextLine()的区别
</h2><h3 id="next-方法">
<a class="header-anchor" href="#next-%e6%96%b9%e6%b3%95"></a>
next() 方法
</h3><blockquote>
<h4 id="空白字符是什么">
<a class="header-anchor" href="#%e7%a9%ba%e7%99%bd%e5%ad%97%e7%ac%a6%e6%98%af%e4%bb%80%e4%b9%88"></a>
空白字符是什么
</h4><p><strong>空白字符</strong>是指在文本中不显示任何内容，但用于控制文本格式和布局的字符。它们在编程和文本处理过程中非常重要，尤其是在处理字符串和文件时。</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>抽象类和接口的异同</title>
      <link>http://localhost:1313/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Wed, 05 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>
        <![CDATA[<h1>抽象类和接口的异同</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="抽象类和接口的异同">
<a class="header-anchor" href="#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e5%92%8c%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%bc%82%e5%90%8c"></a>
抽象类和接口的异同
</h1><h2 id="1-抽象类">
<a class="header-anchor" href="#1-%e6%8a%bd%e8%b1%a1%e7%b1%bb"></a>
1. 抽象类
</h2><h3 id="11-概念">
<a class="header-anchor" href="#11-%e6%a6%82%e5%bf%b5"></a>
1.1 概念
</h3><p><strong>含有抽象方法</strong>的类，在Java中使用abstract修饰</p>
<h3 id="12-包含内容">
<a class="header-anchor" href="#12-%e5%8c%85%e5%90%ab%e5%86%85%e5%ae%b9"></a>
1.2 包含内容
</h3><p>具有普通的类具有的所有内容，除此之外还具有抽象方法，说白了就是<strong>具有抽象方法的普通类（但是通过abstract修饰）</strong> ，具体可以包含的内容为：</p>
        
        <hr><p>本文2025-11-05首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>@RequestPart与其他注解的区分</title>
      <link>http://localhost:1313/post/@requestpart%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%86/</link>
      <pubDate>Sat, 08 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/@requestpart%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%86/</guid>
      <description>
        <![CDATA[<h1>@RequestPart与其他注解的区分</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="requestpart与其他注解的区分">
<a class="header-anchor" href="#requestpart%e4%b8%8e%e5%85%b6%e4%bb%96%e6%b3%a8%e8%a7%a3%e7%9a%84%e5%8c%ba%e5%88%86"></a>
@RequestPart与其他注解的区分
</h1><h2 id="1--enctype的常见类型">
<a class="header-anchor" href="#1--enctype%e7%9a%84%e5%b8%b8%e8%a7%81%e7%b1%bb%e5%9e%8b"></a>
1.  enctype的常见类型
</h2><p>HTML 表单的 <code>enctype</code>属性主要用于定义表单数据在发送到服务器之前的编码方式，这对于确保数据（尤其是文件）能正确传输至关重要。它主要有以下三种类型：</p>
        
        <hr><p>本文2025-11-08首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>JMH的使用</title>
      <link>http://localhost:1313/post/jmh%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 11 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/jmh%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>
        <![CDATA[<h1>JMH的使用</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="jmh的使用">
<a class="header-anchor" href="#jmh%e7%9a%84%e4%bd%bf%e7%94%a8"></a>
JMH的使用
</h1><h2 id="1-与jmeter的区别">
<a class="header-anchor" href="#1-%e4%b8%8ejmeter%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
1. 与JMeter的区别
</h2><h3 id="11-核心区别和选择">
<a class="header-anchor" href="#11-%e6%a0%b8%e5%bf%83%e5%8c%ba%e5%88%ab%e5%92%8c%e9%80%89%e6%8b%a9"></a>
1.1 核心区别和选择
</h3><table>
  <thead>
      <tr>
          <th>特性</th>
          <th>JMH</th>
          <th>JMeter</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>测试类型</strong></td>
          <td>微基准测试（Microbenchmark）</td>
          <td>负载测试、压力测试（Load/Stress Test）</td>
      </tr>
      <tr>
          <td><strong>测试粒度</strong></td>
          <td>方法级别，代码级</td>
          <td>系统级别，接口/服务级</td>
      </tr>
      <tr>
          <td><strong>测试精度</strong></td>
          <td>毫秒级/微秒级</td>
          <td>秒级</td>
      </tr>
      <tr>
          <td><strong>主要用途</strong></td>
          <td><strong>测试</strong>和<strong>优化</strong>代码片段的性能</td>
          <td>评估系统在高并发下的整体性能</td>
      </tr>
      <tr>
          <td><strong>执行方式</strong></td>
          <td>在JVM内部运行，需要编写Java代码</td>
          <td>从外部模拟用户请求，通过GUI（图形用户界面）配置</td>
      </tr>
      <tr>
          <td><strong>典型问题</strong></td>
          <td>ArrayList和LinkedList的遍历哪个更快</td>
          <td>我的网站能否承受 1000 个用户同时访问？</td>
      </tr>
  </tbody>
</table>
<h3 id="12-核心用途的区别">
<a class="header-anchor" href="#12-%e6%a0%b8%e5%bf%83%e7%94%a8%e9%80%94%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
1.2 核心用途的区别
</h3><ul>
<li>
<p><strong>JMH</strong>：是由 OpenJDK 团队开发的一款专门用于 ​<strong>​Java 代码微基准测试​</strong>​ 的工具，用于测量和比较一小段代码/片段的性能，通过一系列复杂的机制（如预热、多线程隔离等）等手段来<strong>避免JVM的即时编译（JIT）优化、GC垃圾回收等因素对测试结果的干扰</strong>，从而<strong>保证测试结果的精确</strong>。</p>
        
        <hr><p>本文2025-11-11首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>Android笔记</title>
      <link>http://localhost:1313/post/android_notes/</link>
      <pubDate>Sat, 23 Nov 2024 11:54:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/android_notes/</guid>
      <description>
        <![CDATA[<h1>Android笔记</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h2 id="安卓基础">
<a class="header-anchor" href="#%e5%ae%89%e5%8d%93%e5%9f%ba%e7%a1%80"></a>
安卓基础
</h2><h2 id="学习前的声明">
<a class="header-anchor" href="#%e5%ad%a6%e4%b9%a0%e5%89%8d%e7%9a%84%e5%a3%b0%e6%98%8e"></a>
学习前的声明
</h2><h3 id="1-语言要求">
<a class="header-anchor" href="#1-%e8%af%ad%e8%a8%80%e8%a6%81%e6%b1%82"></a>
1. 语言要求
</h3><ul>
<li>本次学习用到的语言为<!-- raw HTML omitted -->Java<!-- raw HTML omitted -->。（<!-- raw HTML omitted -->Kotlin<!-- raw HTML omitted -->虽然为Android官方推荐语言，但Java与Kotlin的关系类似于C与C++的关系，学好了Java，便能比较快地上手Kotlin）</li>
</ul>
<h3 id="2-设置主界面">
<a class="header-anchor" href="#2-%e8%ae%be%e7%bd%ae%e4%b8%bb%e7%95%8c%e9%9d%a2"></a>
2. 设置主界面
</h3><ul>
<li>
<p>在<!-- raw HTML omitted -->AndroidManifest.xml<!-- raw HTML omitted -->文件中，在如图所示的位置改为想要作为主界面的的java文件名（注意别忘了名称开头要加点）</p>
        
        <hr><p>本文2024-11-23首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-05-23</p>]]>
      </description>
      
        <category>Android</category>
      
    </item>
    
  </channel>
</rss>
