<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>meeting_smile&#39;s blog</title>
    <link>http://localhost:1313/algolia.json</link>
    <description>Recent content from meeting_smile&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>2054865827@qq.com (meeting_smile)</managingEditor>
    <webMaster>2054865827@qq.com (meeting_smile)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 25 Nov 2025 16:46:00 -0700</lastBuildDate>
    
    
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>使用IDEA的Maven导出jar包失败</title>
      <link>http://localhost:1313/post/%E4%BD%BF%E7%94%A8idea%E7%9A%84maven%E5%AF%BC%E5%87%BAjar%E5%8C%85%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Wed, 09 Jul 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/%E4%BD%BF%E7%94%A8idea%E7%9A%84maven%E5%AF%BC%E5%87%BAjar%E5%8C%85%E5%A4%B1%E8%B4%A5/</guid>
      <description>
        <![CDATA[<h1>使用IDEA的Maven导出jar包失败</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h2 id="使用idea的maven导出jar包失败">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8idea%e7%9a%84maven%e5%af%bc%e5%87%bajar%e5%8c%85%e5%a4%b1%e8%b4%a5"></a>
使用IDEA的Maven导出jar包失败
</h2><ul>
<li>
<p>错误还原：项目使用的是jdk1.8，先使用maven的Lifecycle中的clean，再package，当使用package时，报错：[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project cinema-manage-system: Fatal error compiling: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does</p>
        
        <hr><p>本文2025-07-09首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>开发工具</category>
      
    </item>
    
    

    <item>
      <title>Java定时任务的实现</title>
      <link>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 15 Sep 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>
        <![CDATA[<h1>Java定时任务的实现</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java定时任务的实现">
<a class="header-anchor" href="#java%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
Java定时任务的实现
</h1><h2 id="1-scheduled注解">
<a class="header-anchor" href="#1-scheduled%e6%b3%a8%e8%a7%a3"></a>
1. @Scheduled注解
</h2><h3 id="引入依赖">
<a class="header-anchor" href="#%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96"></a>
引入依赖
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- Spring Boot Schedule依赖 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><h3 id="使用方法">
<a class="header-anchor" href="#%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95"></a>
使用方法
</h3><ul>
<li>
<p>首先，在定时任务方法所在的类加上 <strong>@Component</strong> 注解</p>
        
        <hr><p>本文2025-09-15首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>框架</category>
      
    </item>
    
    

    <item>
      <title>Set和Map的遍历</title>
      <link>http://localhost:1313/post/set%E5%92%8Cmap%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/set%E5%92%8Cmap%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>
        <![CDATA[<h1>Set和Map的遍历</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="set和map的遍历">
<a class="header-anchor" href="#set%e5%92%8cmap%e7%9a%84%e9%81%8d%e5%8e%86"></a>
Set和Map的遍历
</h1><h2 id="1-set的遍历">
<a class="header-anchor" href="#1-set%e7%9a%84%e9%81%8d%e5%8e%86"></a>
1. Set的遍历
</h2><p>遍历set并将其复制给新的数组ret</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> ret <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>        Iterator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> set.<span style="color:#a6e22e">iterator</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(iterator.<span style="color:#a6e22e">hasNext</span>()) {
</span></span><span style="display:flex;"><span>            ret<span style="color:#f92672">[</span>cnt<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> iterator.<span style="color:#a6e22e">next</span>();<span style="color:#75715e">//next()：获取下一个值</span>
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="2-map的遍历">
<a class="header-anchor" href="#2-map%e7%9a%84%e9%81%8d%e5%8e%86"></a>
2. Map的遍历
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer,Integer<span style="color:#f92672">&gt;</span> entry : map.<span style="color:#a6e22e">entrySet</span>()) {
</span></span><span style="display:flex;"><span>    ret<span style="color:#f92672">[</span>cnt<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">getValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>java基础——线程相关</title>
      <link>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</guid>
      <description>
        <![CDATA[<h1>java基础——线程相关</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java基础线程相关">
<a class="header-anchor" href="#java%e5%9f%ba%e7%a1%80%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%85%b3"></a>
java基础——线程相关
</h1><p><strong>本人在阿里暑期实习单招落榜(2025.6.4)之后，下定决心补全java基础知识时做的笔记</strong></p>
<h2 id="1多线程">
<a class="header-anchor" href="#1%e5%a4%9a%e7%ba%bf%e7%a8%8b"></a>
1.多线程
</h2><h3 id="11-多线程实现的三种方式">
<a class="header-anchor" href="#11-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%ae%9e%e7%8e%b0%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f"></a>
1.1 多线程实现的三种方式
</h3><h4 id="111-继承thread类">
<a class="header-anchor" href="#111-%e7%bb%a7%e6%89%bfthread%e7%b1%bb"></a>
1.1.1 继承Thread类
</h4><ul>
<li><strong>定义MyThread类，重写run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> getName());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyThread对象</span>
</span></span><span style="display:flex;"><span>        MyThread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        MyThread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyThread();
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现runnable接口">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3"></a>
1.1.2 实现Runnable接口
</h4><ul>
<li><strong>定义MyRunnable接口，实现run方法：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRunnable</span> <span style="color:#66d9ef">implements</span> Runnable{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取到当前执行该方法的Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Hello,&#34;</span><span style="color:#f92672">+</span> t.<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程：</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyRunnable对象</span>
</span></span><span style="display:flex;"><span>        MyRunnable myRunnable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyRunnable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.利用MyRunnable对象创建Thread对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(myRunnable);
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程1&#34;</span>);
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程2&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        t2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="112-实现callable接口可获取线程运行结果">
<a class="header-anchor" href="#112-%e5%ae%9e%e7%8e%b0callable%e6%8e%a5%e5%8f%a3%e5%8f%af%e8%8e%b7%e5%8f%96%e7%ba%bf%e7%a8%8b%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c"></a>
1.1.2 实现Callable接口（可获取线程运行结果）
</h4><ul>
<li><strong>定义MyCallable类</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCallable</span> <span style="color:#66d9ef">implements</span> Callable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//求1~100的和</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> 100; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum<span style="color:#f92672">+=</span>i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>实现多线程</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) <span style="color:#66d9ef">throws</span> ExecutionException, InterruptedException {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//1.创建MyCallable对象</span>
</span></span><span style="display:flex;"><span>        MyCallable myCall <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyCallable();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//2.创建FutureTask对象，用于管理单线程运行的结果</span>
</span></span><span style="display:flex;"><span>        FutureTask<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> ft <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">&lt;&gt;</span>(myCall);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//3.通过FutureTask对象来创建线程对象</span>
</span></span><span style="display:flex;"><span>        Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(ft);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//4.利用Thread对象启动线程</span>
</span></span><span style="display:flex;"><span>        t1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//5.利用FutureTask的get()方法获取线程运行的结果</span>
</span></span><span style="display:flex;"><span>        Integer result <span style="color:#f92672">=</span> ft.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(result);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><hr>
<h3 id="12-三种方式的比较">
<a class="header-anchor" href="#12-%e4%b8%89%e7%a7%8d%e6%96%b9%e5%bc%8f%e7%9a%84%e6%af%94%e8%be%83"></a>
1.2 三种方式的比较
</h3><table>
  <thead>
      <tr>
          <th>实现方式</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>继承Thread类</td>
          <td>编程比较简单，可以直接使用Thread类中的方法</td>
          <td>扩展性较差，不能再继承其他的类</td>
      </tr>
      <tr>
          <td>实现Runnable接口</td>
          <td>扩展性强，实现该接口的同时还可以继承其他的类</td>
          <td>编程相对复杂，不能直接使用Thread类中的方法</td>
      </tr>
      <tr>
          <td>实现Callable接口</td>
          <td>- 扩展性强（同样可继承其他类）<!-- raw HTML omitted -->- 支持返回值（通过FutureTask获取）<!-- raw HTML omitted -->- 支持抛出检查异常</td>
          <td>- 编程最复杂<!-- raw HTML omitted -->- 需配合ExecutorService使用<!-- raw HTML omitted -->- 不能直接使用Thread类方法</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="13-thread的常见成员方法">
<a class="header-anchor" href="#13-thread%e7%9a%84%e5%b8%b8%e8%a7%81%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95"></a>
1.3 Thread的常见成员方法
</h3><table>
  <thead>
      <tr>
          <th>方法名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>String getName()</code></strong></td>
          <td>返回此线程的名称</td>
      </tr>
      <tr>
          <td><strong><code>void setName(String name)</code></strong></td>
          <td>设置线程的名字（构造方法也可以设置名字）</td>
      </tr>
      <tr>
          <td><strong><code>static Thread currentThread()</code></strong></td>
          <td>获取当前线程的对象</td>
      </tr>
      <tr>
          <td><strong><code>static void sleep(long time)</code></strong></td>
          <td>让线程休眠指定的时间，单位为毫秒</td>
      </tr>
      <tr>
          <td><strong><code>setPriority(int newPriority)</code></strong></td>
          <td>设置线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final int getPriority()</code></strong></td>
          <td>获取线程的优先级</td>
      </tr>
      <tr>
          <td><strong><code>final void setDaemon(boolean on)</code></strong></td>
          <td>设置为守护线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void yield()</code></strong></td>
          <td>出让线程/礼让线程</td>
      </tr>
      <tr>
          <td><strong><code>public static void join()</code></strong></td>
          <td>插入线程/插队线程</td>
      </tr>
  </tbody>
</table>
<h4 id="131-sleeplong-time">
<a class="header-anchor" href="#131-sleeplong-time"></a>
1.3.1 sleep(long time)
</h4><ul>
<li>
<p><strong>描述：</strong> 让使用当前函数的线程休眠指定时间。</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>Java的四种引用</title>
      <link>http://localhost:1313/post/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</guid>
      <description>
        <![CDATA[<h1>Java的四种引用</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java的四种引用">
<a class="header-anchor" href="#java%e7%9a%84%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8"></a>
Java的四种引用
</h1><h2 id="1-强引用">
<a class="header-anchor" href="#1-%e5%bc%ba%e5%bc%95%e7%94%a8"></a>
1. 强引用
</h2><h3 id="11-概念">
<a class="header-anchor" href="#11-%e6%a6%82%e5%bf%b5"></a>
1.1 概念
</h3><p>被直接指向的对象实例，即使JVM的堆内存不足爆出OOM错误也不会释放强引用的对象。</p>
<h3 id="12-强引用对象的回收">
<a class="header-anchor" href="#12-%e5%bc%ba%e5%bc%95%e7%94%a8%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9b%9e%e6%94%b6"></a>
1.2 强引用对象的回收
</h3><p>只有当对象无法通过GC Root找到（没有被引用），强引用的对象才可被回收</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>Java 输入输出总结</title>
      <link>http://localhost:1313/post/java-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 16 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/java-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</guid>
      <description>
        <![CDATA[<h1>Java 输入输出总结</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="java-输入输出总结">
<a class="header-anchor" href="#java-%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%80%bb%e7%bb%93"></a>
Java 输入输出总结
</h1><h2 id="scanner中nextnextint和nextline的区别">
<a class="header-anchor" href="#scanner%e4%b8%adnextnextint%e5%92%8cnextline%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
Scanner中，Next()、NextInt()和NextLine()的区别
</h2><h3 id="next-方法">
<a class="header-anchor" href="#next-%e6%96%b9%e6%b3%95"></a>
next() 方法
</h3><blockquote>
<h4 id="空白字符是什么">
<a class="header-anchor" href="#%e7%a9%ba%e7%99%bd%e5%ad%97%e7%ac%a6%e6%98%af%e4%bb%80%e4%b9%88"></a>
空白字符是什么
</h4><p><strong>空白字符</strong>是指在文本中不显示任何内容，但用于控制文本格式和布局的字符。它们在编程和文本处理过程中非常重要，尤其是在处理字符串和文件时。</p>
        
        <hr><p>本文2025-10-16首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
    

    <item>
      <title>Linux/Unix shell命令的反斜杠是​​续行符​</title>
      <link>http://localhost:1313/post/linux%E6%88%96unix%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0%E6%98%AF%E7%BB%AD%E8%A1%8C%E7%AC%A6/</link>
      <pubDate>Tue, 21 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/linux%E6%88%96unix%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0%E6%98%AF%E7%BB%AD%E8%A1%8C%E7%AC%A6/</guid>
      <description>
        <![CDATA[<h1>Linux/Unix shell命令的反斜杠是​​续行符​</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="linuxunix-shell命令的反斜杠是续行符">
<a class="header-anchor" href="#linuxunix-shell%e5%91%bd%e4%bb%a4%e7%9a%84%e5%8f%8d%e6%96%9c%e6%9d%a0%e6%98%af%e7%bb%ad%e8%a1%8c%e7%ac%a6"></a>
Linux/Unix shell命令的反斜杠是​​续行符​
</h1><h2 id="实例">
<a class="header-anchor" href="#%e5%ae%9e%e4%be%8b"></a>
实例
</h2><p>如有以下配置JDK的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./configure <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --with-debug-level<span style="color:#f92672">=</span>release <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --with-native-debug-symbols<span style="color:#f92672">=</span>internal <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ...
</span></span></code></pre></div><h2 id="解释">
<a class="header-anchor" href="#%e8%a7%a3%e9%87%8a"></a>
解释
</h2><p>命令当中的 <strong>反斜杠&quot;&quot;</strong> 表示的是<strong>续行符</strong> ，用于告诉shell：该命令还没有结束，换到了下一行，shell应该从<strong>下一行接着读</strong>，在逻辑上这些行会被<strong>合并为一条完整命令</strong></p>
        
        <hr><p>本文2025-10-21首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>操作系统</category>
      
    </item>
    
    

    <item>
      <title>判断字段是否非空不能用等号的原因</title>
      <link>http://localhost:1313/post/%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E9%9D%9E%E7%A9%BA%E4%B8%8D%E8%83%BD%E7%94%A8%E7%AD%89%E5%8F%B7%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Tue, 28 Oct 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E9%9D%9E%E7%A9%BA%E4%B8%8D%E8%83%BD%E7%94%A8%E7%AD%89%E5%8F%B7%E7%9A%84%E5%8E%9F%E5%9B%A0/</guid>
      <description>
        <![CDATA[<h1>判断字段是否非空不能用等号的原因</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="判断字段是否非空不能用等号的原因">
<a class="header-anchor" href="#%e5%88%a4%e6%96%ad%e5%ad%97%e6%ae%b5%e6%98%af%e5%90%a6%e9%9d%9e%e7%a9%ba%e4%b8%8d%e8%83%bd%e7%94%a8%e7%ad%89%e5%8f%b7%e7%9a%84%e5%8e%9f%e5%9b%a0"></a>
判断字段是否非空不能用等号的原因
</h1><p>在MySQL中，判断字段是否为空（<code>NULL</code>）必须使用 <code>IS NULL</code>或 <code>IS NOT NULL</code>，而不能使用等号（例如 <code>= NULL</code>或 <code>!= NULL</code>），这是因为 <code>NULL</code>在数据库里代表一个特殊概念。</p>
        
        <hr><p>本文2025-10-28首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>数据库</category>
      
    </item>
    
    

    <item>
      <title>Zookeeper&#43;Kafka集群的部署与启动</title>
      <link>http://localhost:1313/post/zookeeper&#43;kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Sat, 01 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/zookeeper&#43;kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%90%AF%E5%8A%A8/</guid>
      <description>
        <![CDATA[<h1>Zookeeper+Kafka集群的部署与启动</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="zookeeperkafka集群的部署与启动">
<a class="header-anchor" href="#zookeeperkafka%e9%9b%86%e7%be%a4%e7%9a%84%e9%83%a8%e7%bd%b2%e4%b8%8e%e5%90%af%e5%8a%a8"></a>
Zookeeper+Kafka集群的部署与启动
</h1><blockquote>
<p>我使用的虚拟机内网IP分别为：192.168.136.129,192.168.136.132,192.168.136.133</p>
        
        <hr><p>本文2025-11-01首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>中间件</category>
      
    </item>
    
    

    <item>
      <title>抽象类和接口的异同</title>
      <link>http://localhost:1313/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Wed, 05 Nov 2025 17:00:00 -0700</pubDate>
      <author>2054865827@qq.com (meeting_smile)</author>
      <guid>http://localhost:1313/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>
        <![CDATA[<h1>抽象类和接口的异同</h1><p>作者：meeting_smile（2054865827@qq.com）</p>
        
          <h1 id="抽象类和接口的异同">
<a class="header-anchor" href="#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e5%92%8c%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%bc%82%e5%90%8c"></a>
抽象类和接口的异同
</h1><h2 id="1-抽象类">
<a class="header-anchor" href="#1-%e6%8a%bd%e8%b1%a1%e7%b1%bb"></a>
1. 抽象类
</h2><h3 id="11-概念">
<a class="header-anchor" href="#11-%e6%a6%82%e5%bf%b5"></a>
1.1 概念
</h3><p><strong>含有抽象方法</strong>的类，在Java中使用abstract修饰</p>
<h3 id="12-包含内容">
<a class="header-anchor" href="#12-%e5%8c%85%e5%90%ab%e5%86%85%e5%ae%b9"></a>
1.2 包含内容
</h3><p>具有普通的类具有的所有内容，除此之外还具有抽象方法，说白了就是<strong>具有抽象方法的普通类（但是通过abstract修饰）</strong> ，具体可以包含的内容为：</p>
        
        <hr><p>本文2025-11-05首发于<a href='http://localhost:1313/'>meeting_smile's blog</a>，最后修改于2025-11-25</p>]]>
      </description>
      
        <category>Java基础</category>
      
    </item>
    
  </channel>
</rss>
