[
  {
    "objectID": "1762905600",
    "permalink": "/post/jmh%E7%9A%84%E4%BD%BF%E7%94%A8/",
    "title": "JMH的使用","content": " JMH的使用 1. 与JMeter的区别 1.1 核心区别和选择 特性 JMH JMeter 测试类型 微基准测试（Microbenchmark） 负载测试、压力测试（Load/Stress Test） 测试粒度 方法级别，代码级 系统级别，接口/服务级 测试精度 毫秒级/微秒级 秒级 主要用途 测试和优化代码片段的性能 评估系统在高并发下的整体性能 执行方式 在JVM内部运行，需要编写Java代码 从外部模拟用户请求，通过GUI（图形用户界面）配置 典型问题 ArrayList和LinkedList的遍历哪个更快 我的网站能否承受 1000 个用户同时访问？ 1.2 核心用途的区别 JMH：是由 OpenJDK 团队开发的一款专门用于 ​​Java 代码微基准测试​​ 的工具，用于测量和比较一小段代码/片段的性能，通过一系列复杂的机制（如预热、多线程隔离等）等手段来避免JVM的即时编译（JIT）优化、GC垃圾回收等因素对测试结果的干扰，从而保证测试结果的精确。\nJMeter ：是Apache组织开发的一款开源的负载和性能测试工具 ，通过模拟大规模用户的访问，对服务器、网络或对象施加压力，从而测试在搞负载下系统的强度、稳定性和整体性能。它关注的是系统级别的指标，如吞吐量、响应时间和错误率等。\n1.3 适用场景的区别 1.3.1 JMH的适用场景 热点代码的优化 ：如可通过JMH进行性能测试，选择性能优秀的方案优化热点代码（利用StringBuffer.append()还是String之间用\u0026amp;quot;+\u0026amp;ldquo;来拼接字符串）。\n算法比较 ：比较不同算法（排序算法、数据结构）在相同输入下的性能表现。\n库/框架的选择 在多个功能相似的库/框架（如JSON序列化）中进行选择时，可通过JVM来进行性能测试并比较。\nJVM特性分析：分析JIT编译、方法内敛等JVM优化策略对代码性能的影响。\n1.3.2 JMeter的使用场景 Web应用/API性能测试 ：对网站、RESTFUL API等服务进行压力测试，确定其能承受的最大并发数，找出其性能瓶颈。\n数据库性能测试 ：通过JMeter模拟大量用户，访问JDBC连接器相关的接口，从而模拟大量数据库增删改查操作，评估数据库性能。\n分布式测试 ：在多台机器上分别部署JMeter对同一个接口进行测试，从而产生远超单机能力的并发负 …","date": "2025-11-11 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762819200",
    "permalink": "/post/ssl%E4%B8%8Etls/ssl%E4%B8%8Etls/",
    "title": "SSL/TLS","content": " SSL/TLS 1. 概念 SSL（Secure Socket Layer）全称安全套接字层协议，是Netscape公司率先采用的网络安全协议。它是在传输通信协议（TCP/IP）上实现的一种安全协议，采用公开密钥技术。SSL广泛支持各种类型的网络。\nTLS（Transport Layer Security）全称传输层安全协议，前身为SSL协议。\nSSL目前已经过时了，而当前的主流是TLS，但由于SSL过于出名，因此经常把TLS与SSL混着叫。\n2. 加密算法 SSL和TLS的过程均同时使用了非对称和对称加密算法，因此有必要先了解这两种类型的算法\n2.1 对称加密算法 加密算法是信息安全的核心技术，主要分为​​对称加密​​和​​非对称加密​​两大类，它们在密钥管理和应用场景上有着根本性的区别。\n2.1.1 概念 对称加密算法指在加密和解密过程中使用同一个密钥，因此也成为共享密钥加密。\n优点是计算量小、加密速度快和效率高，适合对大量数据进行加密 。\n缺点是难以分发和管理密钥（为了安全：要确保密钥不能明文发送；为了确保通信双方必须共享地使用同一个密钥：发送方和接收方的密钥是相同的）\n2.1.2 常见的对称加密算法 AES (Advanced Encryption Standard) ：高级加密标准，支持128、192、256位三种密钥长度，是目前使用最广泛的对称加密标准，具有安全 、高效 的特点。\nDES （Data Encryption Standard）：数据加密标准，一种早期的分组加密算法（即对数据按照相同的长度进行分组再加密）支持52位的密钥长度，容易被暴力破解，因此安全性较差，目前已经过时。\n3DES（Triple Data Encryption Standard）：是DES的增强版，即通过对每个数据块进行三次DES加密来提高安全性，虽然比DES安全，但处理速度较慢，目前也正被AES取代。\nRC4 ：一种流密码算法，曾因速度快被广泛使用（如WEP协议），但后来发现了严重的安全漏洞，已不再安全，不应继续使用。\n2.2 非对称加密算法 2.2.1 概念 非对称加密算法使用一对密钥：一个公钥（Public Key）和一个密钥（Private Key）。公钥可以公开给任何人（可以明文传输），私钥必须严格保密。公钥和私钥都可分别用于加密和解密，但对应的用途不同：\n用于加 …","date": "2025-11-10 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762646400",
    "permalink": "/post/@requestpart%E4%B8%8E%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%86/",
    "title": "@RequestPart与其他注解的区分","content": " @RequestPart与其他注解的区分 1. enctype的常见类型 HTML 表单的 enctype属性主要用于定义表单数据在发送到服务器之前的编码方式，这对于确保数据（尤其是文件）能正确传输至关重要。它主要有以下三种类型：\n属性值 描述 典型应用场景 application/x-www-form-urlencoded 默认编码方式。将所有字符进行编码，转换为名称/值对的形式（例如，空格变为 \u0026amp;quot;+\u0026amp;quot;加号，特殊字符转换为 ASCII HEX 值）。 传输普通的文本数据，适合没有文件上传的表单。 multipart/form-data 将表单数据编码为一条复合消息，表单中的每个字段对应消息中的一个独立部分，数据通过边界符（boundary）进行分隔。不对字符进行编码，可以完整地传输二进制数据。 必须用于包含文件上传控件（\u0026amp;lt;input type=\u0026amp;quot;file\u0026amp;quot;\u0026amp;gt;）的表单。 text/plain 将数据以纯文本形式进行编码，空格会转换为 \u0026amp;quot;+\u0026amp;quot;加号，但不对特殊字符进行编码。 应用场景有限，通常用于通过表单直接发送邮件（action=\u0026amp;quot;mailto:...\u0026amp;quot;）。 💡 重要注意事项 方法依赖：当使用 multipart/form-data时，表单的 method属性必须设置为 POST。对于 GET 请求，enctype属性通常会被忽略。\n默认行为：如果在 \u0026amp;lt;form\u0026amp;gt;标签中未明确指定 enctype属性，浏览器将自动采用 application/x-www-form-urlencoded作为默认编码方式。\n2. @RequestPart与其他注解的区分 简单直接地回答您：不包括。@RequestPart注解有自己非常特定的用途，它不会获取由 @PathVariable、@RequestParam、@RequestHeader、@CookieValue或 @RequestBody所处理的数据。\n这些注解各自负责从 HTTP 请求的不同部分获取数据，分工明确。为了更清晰地展示它们的区别，我为您准备了一个对比表格：\n📊 各注解职责速览表 注解 主要职责（获取数据的来源） 适用场景举例 @RequestPart 从 **multipart/form-data**类型的请求体 …","date": "2025-11-08 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762387200",
    "permalink": "/post/join%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9A%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6/",
    "title": "join是否必须指定连接条件","content": " join是否必须指定连接条件 不指定连接条件通常不会直接导致数据库报语法错误，但绝大多数情况下会产生一个你可能并不期望的结果——笛卡尔积（Cart卡尔积）。\n即要想获得笛卡尔乘积，则无需指定连接条件。\n若两个表无相同列，则此时进行连接产生的就是笛卡尔乘积。\n下面这个表格帮你清晰地了解不同连接类型在不指定条件时的行为。\n连接类型 是否必须指定条件 不指定条件的结果 INNER JOIN(内连接) 强烈建议指定 产生笛卡尔积，返回两表行数的乘积，结果通常无意义。 LEFT/RIGHT JOIN(外连接) 强烈建议指定 同样会产生笛卡尔积。 CROSS JOIN(交叉连接) 否 这是唯一特例。它被设计用来生成笛卡尔积，是明确期望此结果时的正确写法。 逗号分隔表 (旧式写法) 强烈建议指定 在WHERE子句中无连接条件时，必然产生笛卡尔积。 💥 理解笛卡尔积 笛卡尔积是一个数学概念。在数据库中，它指的是将第一个表的每一行与第二个表的每一行进行强制组合。例如，如果表A有10行，表B有20行，那么它们的笛卡尔积将产生 10 × 20 = 200 行结果。\n这种结果集通常非常庞大，且包含大量完全没有逻辑关联的数据，因此绝大部分情况下都不是查询的本意，是一种需要避免的“错误”。\n✅ 如何正确指定连接条件 为了避免意外的笛卡尔积，你需要在查询中明确指定表之间如何关联。标准的做法是使用 ON子句。\n内连接示例\n-- 正确的写法：明确指定连接条件\rSELECT * FROM student INNER JOIN class ON student.class_id = class.id; 这个查询只会返回那些在student表中有class_id且在class表中有对应id的记录。\n外连接示例\n-- 返回所有学生，即使他们没有对应的班级信息\rSELECT * FROM student LEFT JOIN class ON student.class_id = class.id; ⚠️ 特别提醒：CROSS JOIN是特例 当你确实需要生成两个表的笛卡尔积时（例如，需要系统性地组合所有产品和所有颜色），应该使用显式的 **CROSS JOIN**关键字。\n-- 这是有意为之的笛卡尔积\rSELECT * FROM table1 CROSS JOIN table2; 使用 CROSS JOIN能使你的意图非常清晰，表明你确实需要这样的组合结果。\n总结 简单来说，不指定连接条件数据库不会报错，但会得到一个几乎总是错误的笛卡尔积结果。除了有意使用 CROSS JOIN的情况，请务必为你的所有连接操作（INNER JOIN, LEFT JOIN等）指定有效的 ON条件。\n","date": "2025-11-05 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762387200",
    "permalink": "/post/sum%E5%92%8Ccount%E7%9A%84%E5%8C%BA%E5%88%AB/",
    "title": "sum和count的区别","content": " sum和count的区别 SQL 中的 SUM和 COUNT是两个最常用的聚合函数，但它们的计算目标和适用场景有本质区别。简单来说，COUNT用于“数个数”，而 SUM用于“算总和”。\n下面这个表格能帮你更直观地看清它们之间的核心差异。\n特性 COUNT SUM 核心功能 统计记录的数量或非NULL值的个数 计算指定列所有数值的总和 返回值 一个整数（行数或非NULL值数量） 一个数值（总和），通常与列的数据类型一致（如整数、小数） 对NULL的处理 COUNT(*)统计所有行，不忽略NULL；COUNT(列名)仅统计该列非NULL值的数量 完全忽略NULL值，只对有效的数值进行相加 适用场景 “有多少个？” - 例如：总用户数、总订单数 “总共是多少？” - 例如：总销售额、总分数 适用数据类型 任何类型（COUNT(*)或 COUNT(1)）；任意类型（COUNT(列名)，但只关心是否存在值） 通常是数值类型（如 INT, DECIMAL, FLOAT） 通过实例加深理解 假设有一张 sales销售表，数据如下：\norder_id product quantity price 1 Apple 5 2.5 2 Banana 10 1.2 3 Orange NULL 3.0 4 Mango 8 4.5 5 NULL 2 NULL 不同的函数会得到不同的结果：\nCOUNT(*): 统计的是总行数，不关心任何列的具体值。\nSELECT COUNT(*) AS total_orders FROM sales; 结果：5（因为表中共有5行记录）\nCOUNT(column): 统计特定列中非NULL值的数量。\nSELECT COUNT(product) AS product_count FROM sales; 结果：4（因为 product列有1个NULL值，被忽略）\nSUM(column): 计算指定数值列中非NULL值的总和。\nSELECT SUM(quantity) AS total_quantity FROM sales; 结果：25（计算过程为：5 + 10 + 8 + 2 = 25，第3行的NULL被忽略）\n关于COUNT的几种常见写法 你可能会遇到 COUNT(*), COUNT(1), COUNT(列名)这几种形式，它们的区别在于：\n**COUNT(*)**和 **COUNT(1)**的功能完全相同，都是统计所有行的数量，包括全为NULL的行。在现代数据库中，它们的性能没有差异，通常推荐使用 COUNT(*)，因为其语义更明确（统计行数）。\n**COUNT(列名)**统计的是该列非NULL值的数量。如果该列存在NULL值，结果可能会小于 COUNT(*)。\n如何选择？ 记住一个简单的原则：\n当你想知道 “有多少个？”（例如，有多少个订单？多少个有效邮箱？）时，使用 COUNT。\n当你想知道 “总共是多少？”（例如，总销售额是多少？总成本是多少？）时，使用 SUM。\n","date": "2025-11-05 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762387200",
    "permalink": "/post/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/",
    "title": "抽象类和接口的异同","content": " 抽象类和接口的异同 1. 抽象类 1.1 概念 含有抽象方法的类，在Java中使用abstract修饰\n1.2 包含内容 具有普通的类具有的所有内容，除此之外还具有抽象方法，说白了就是具有抽象方法的普通类（但是通过abstract修饰） ，具体可以包含的内容为：\n（任意修饰符的）抽象方法\n（任意修饰符的）的具体、静态方法\n（任意修饰符的）普通、静态成员变量\n（任意修饰符的）常量\n（任意修饰符的）含有/不含 方法体构造方法\n例子（试过了没有发生报错）：\npublic abstract class AAbstract { /** * 抽象方法可以具有以下内容（普通类可以有的抽象类都有，且抽象类还能具有抽象方法）： */ //1.（任意修饰符的普通）成员变量 public int i; //2.（任意修饰符的静态）成员变量 public static final int j = 0; //3.含有/不含方法体的构造方法 private AAbstract(){ this.i = 1; } //4.（任意修饰符的）抽象方法 public abstract void a(); //5.（任意修饰符的）具体方法 public void b(){ } } 1.3 继承 1.3.1 子类与父类 在Java中，子类 可以通过关键字extends 抽象类，来实现对抽象类的继承 ，在继承这一层关系中，才有子类 与父类 的概念 1.3.2 单继承 一般来说，一个类（包括抽象类）只能实现单继承\n特殊情况，接口可以实现多继承 ，但是 继承的只能也是接口\n1.3.3 什么类可以被继承 所有的类（接口不行）都可以被继承，但是 声明了final的类不能被继承 1.3.4 重写父类方法 子类如果继承了父类，必须重写父类的所有抽象方法 （普通方法可选，不强制要求）；但是如果子类为抽象类，则不强制要求重写父类的抽象方法\n子类不能重写父类用final、private和static修饰的方法 ，其中：\n父类的final方法 只能被子类继承，不能被重写，但是可以被子类的实例使用\n父类的private方法 只能被子类继承、不能被重写，也不能被子类内部和子类实例使用使用，相当于子类完全用不了也看不见。这是因为private修饰符只允许该方法在父类内部使用。\n父类的static方法 可以被子类继承、子类的内部和子类 …","date": "2025-11-05 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1762041600",
    "permalink": "/post/zookeeper+kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%90%AF%E5%8A%A8/",
    "title": "Zookeeper+Kafka集群的部署与启动","content": " Zookeeper+Kafka集群的部署与启动 我使用的虚拟机内网IP分别为：192.168.136.129,192.168.136.132,192.168.136.133\n1. 完整步骤 见链接：Zookeeper 和 Kafka 工作原理及如何搭建 Zookeeper集群 + Kafka集群_kafka集群安装部署-CSDN博客\n2. Zookeeper的部署与启动 2.1 添加集群信息 cd /usr/local/zookeeper-3.5.7/conf/ (在/usr/local/zookeeper-3.5.7/目录下输入./bin/zkCli.sh可进入客户端) vim zoo.cfg #添加集群信息 server.1=192.168.30.107:3188:3288 server.2=192.168.30.108:3188:3288 server.3=192.168.30.109:3188:3288 2.2 设置集群的节点 在每个节点的dataDir指定的目录下创建一个 myid 的文件：\necho 1 \u0026amp;gt; /usr/local/zookeeper-3.5.7/data/myid echo 2 \u0026amp;gt; /usr/local/zookeeper-3.5.7/data/myid echo 3 \u0026amp;gt; /usr/local/zookeeper-3.5.7/data/myid 2.3 启动节点、查看状态 # 启动节点 service zookeeper start # 查看当前状态 service zookeeper status 3. Kafka集群的部署与启动 kafka路径在：/usr/local/kafka/\n3.1 指定集群节点、指定zookeeper连接地址 cd /usr/local/kafka/config/ # 修改配置文件 vim server.properties broker.id=0 ●21行，broker的全局唯一编号，每个broker不能重复，因此要在其他机器上配置 broker.id=1、broker.id=2 zookeeper.connect=192.168.136.129:2181,192.168.136.132:2181,192.168.136.133:2181 ●123行，配置连接Zookeeper …","date": "2025-11-01 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1761696000",
    "permalink": "/post/%E5%88%A4%E6%96%AD%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E9%9D%9E%E7%A9%BA%E4%B8%8D%E8%83%BD%E7%94%A8%E7%AD%89%E5%8F%B7%E7%9A%84%E5%8E%9F%E5%9B%A0/",
    "title": "判断字段是否非空不能用等号的原因","content": " 判断字段是否非空不能用等号的原因 在MySQL中，判断字段是否为空（NULL）必须使用 IS NULL或 IS NOT NULL，而不能使用等号（例如 = NULL或 != NULL），这是因为 NULL在数据库里代表一个特殊概念。\nNULL的本质与比较规则 NULL表示一个未知的、不存在的或者缺失的值。它不是一个具体的数值或字符串，因此不能像普通值那样进行比较 。\n关键点在于，任何与 NULL进行的比较操作（包括使用 =、!=、\u0026lt;\u0026gt;等运算符）结果都不是 TRUE或 FALSE，而是 UNKNOWN。在SQL的逻辑处理中，WHERE子句只返回条件判断为 TRUE的行，而会过滤掉结果为 FALSE或 UNKNOWN的行。所以，当你使用 field = NULL这样的条件时，数据库无法确认两者相等（因为NULL是未知的），结果总是 UNKNOWN，最终不会返回任何记录 。\n正确的判断方法与替代函数 ​​使用 IS NULL和 IS NOT NULL​​\n这是专门为判断 NULL值设计的运算符 。\n查询空值：SELECT * FROM table_name WHERE column_name IS NULL;\n查询非空值：SELECT * FROM table_name WHERE column_name IS NOT NULL;\n​​使用函数处理空值​​\n如果你希望将 NULL转换为一个具体的默认值后再参与比较，可以使用函数：\n​​IFNULL(column_name, default_value)​​：如果 column_name为 NULL，则返回 default_value，否则返回 column_name本身 。例如，SELECT * FROM users WHERE IFNULL(name, '') = '';会找出所有姓名为空或空字符串的记录 。\n​​COALESCE(value1, value2, ...)​​：返回参数列表中第一个非 NULL的值 。这在有多个备选值时非常有用。\n核心区别速查表 为了让概念更清晰，可以参考下表：\n特性 NULL 空字符串 ('') 数字 0 ​​含义​​ 未知/缺失的值 一个已知的、长度为0的字符串 一个具体的数值 ​​比较运算符​​ 必须使用 IS NULL/IS NOT NULL 可以使用 = ''或 != '' 可以使用 = 0或 != 0 ​​逻辑结果​​ =NULL返回 UNKNOWN =''返回 TRUE或 FALSE =0返回 TRUE或 FALSE 简单来说，记住 ​​NULL是一个表示“未知”的标记，而不是一个值​​，就能理解为什么不能用等号来判断了。\n","date": "2025-10-28 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1761091200",
    "permalink": "/post/linux%E6%88%96unix%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0%E6%98%AF%E7%BB%AD%E8%A1%8C%E7%AC%A6/",
    "title": "Linux/Unix shell命令的反斜杠是​​续行符​","content": " Linux/Unix shell命令的反斜杠是​​续行符​ 实例 如有以下配置JDK的命令：\n./configure \\ --with-debug-level=release \\ --with-native-debug-symbols=internal \\ ... 解释 命令当中的 反斜杠\u0026quot;\u0026quot; 表示的是续行符 ，用于告诉shell：该命令还没有结束，换到了下一行，shell应该从下一行接着读，在逻辑上这些行会被合并为一条完整命令\n使用场景 将单个长命令分成多行书写\n说明 利用了 续行符 之后，下一行的前导空格 将被忽略，因此为了方便阅读，通常可以在下一行的开始加上空格来缩进\n续行符 单指反斜杠 ” / “ ，而不是空格+反斜杠 ，这当中的空格是用于将每一行的命令分隔开 ，因此上述命令也等效为：\n./configure --with-debug-level=release --with-native-debug-symbols=internal --with-jvm-variants=server --enable-unlimited-crypto --disable-warnings-as-errors --with-toolchain-type=gcc --with-boot-jdk=/usr/lib/jvm/java-17-openjdk-amd64 --with-jmh=build/jmh/jars ","date": "2025-10-21 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1760659200",
    "permalink": "/post/java-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/",
    "title": "Java 输入输出总结","content": " Java 输入输出总结 Scanner中，Next()、NextInt()和NextLine()的区别 next() 方法 空白字符是什么 空白字符是指在文本中不显示任何内容，但用于控制文本格式和布局的字符。它们在编程和文本处理过程中非常重要，尤其是在处理字符串和文件时。\n常见的空白字符\n在C语言和其他编程语言中，常见的空白字符包括：\n空格符（Space）：ASCII码为32，表示一个普通的空格。\n制表符（Tab）：ASCII码为9，用于水平制表。\n换行符（Newline）：ASCII码为10，用于将光标移到下一行的开头。\n回车符（Carriage Return）：ASCII码为13，用于将光标移到当前行的开头。\n垂直制表符（Vertical Tab）：ASCII码为11，用于垂直制表。\n换页符（Form Feed）：ASCII码为12，用于将光标移到下一页的开头。\n这些字符在不同的操作系统和文本编辑器中可能表现不同。例如，在Windows系统中，换行通常由回车符和换行符组合表示（\\r\\n），而在Unix和Linux系统中，换行通常只由换行符表示（\\n）。\n用于读取输入中的下一个标记（token），它会跳过任何前导的空白字符（如空格、Tab 键等），并在遇到下一个空白字符时停止读取。这意味着 next() 方法不能读取包含空格的字符串。例如：\nimport java.util.Scanner; public class Example { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\u0026amp;#34;请输入一个字符串：\u0026amp;#34;); String input = sc.next(); System.out.println(\u0026amp;#34;输入的字符串是：\u0026amp;#34; + input); } } 如果输入 Hello World，输出将是 Hello，因为 next() 方法在遇到空格(也是空白字符）时停止读取。\nnextLine() 方法 nextLine() 方法用于读取整行输入的数据，包括空格和换行符。当调用 nextLine() 时，它会读取输入的整行内容，直到遇到换行符 \\n 为止，并将其作为字符串返回。\nimport …","date": "2025-10-16 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1760659200",
    "permalink": "/post/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/",
    "title": "Java的四种引用","content": " Java的四种引用 1. 强引用 1.1 概念 被直接指向的对象实例，即使JVM的堆内存不足爆出OOM错误也不会释放强引用的对象。\n1.2 强引用对象的回收 只有当对象无法通过GC Root找到（没有被引用），强引用的对象才可被回收\n在对象当中重写finialize方法(在Java 9 之后已经被启用），当对象被回收之后即可被调用，便可通过观察finialize方法是否被调用从而判断对象是否被回收：\n@Data //lombok：快速生成get set方法 public class Tiger { private String name; private int age; @Override @Deprecated protected void finalize() throws Throwable { System.out.println(\u0026amp;#34;Triger被回收了\u0026amp;#34;); } } 测试：只有tiger指向对象实例，当把tiger赋为空时，对象实例就没有任何指向了，此时便会回收对象实例并触发finalize方法\npublic static void main(String[] args) { Tiger tiger = new Tiger(); System.out.println(\u0026amp;#34;强引用的对象（GC前）：\u0026amp;#34;+tiger.hashCode()); tiger = null; System.gc(); } 运行结果：\n强引用的对象（GC前）：3524 Triger被回收了 当把tiger = null 这一行代码去掉，则不会回收该强引用的对象，此时运行结果只有：\n强引用的对象（GC前）：3524 1.3 内存不存时是否会回收 1.3.1 调整堆内存上限 首先通过JVM参数，设置堆内存上限为20MB，设置步骤如下：\n点击运行符 ：\n点击Modify Run Configuration\n选择Modify options\n选择Add VM options\n在VM options 处设置 -Xmx20M\n1.3.2 测试 首先先创建一个大小为10MB的Byte，当创建另一个10MB大小的数组时，堆内存不足（除了这两个数组之外，肯定还有其他对象占用堆内存，因此此时总占用内存一定大于20MB），此时进行了垃圾回收，但是用于强引用对象仍然有被指向，无 …","date": "2025-10-16 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1760659200",
    "permalink": "/post/java%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/",
    "title": "java基础——线程相关","content": " java基础——线程相关 本人在阿里暑期实习单招落榜(2025.6.4)之后，下定决心补全java基础知识时做的笔记\n1.多线程 1.1 多线程实现的三种方式 1.1.1 继承Thread类 定义MyThread类，重写run方法： public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i \u0026amp;lt; 100; i++) { System.out.println(\u0026amp;#34;Hello,\u0026amp;#34;+ getName()); } } } 实现多线程： public static void main(String[] args) { //1.创建MyThread对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); t1.setName(\u0026amp;#34;线程1\u0026amp;#34;); t2.setName(\u0026amp;#34;线程2\u0026amp;#34;); //2.利用Thread对象启动线程 t1.start(); t2.start(); } 1.1.2 实现Runnable接口 定义MyRunnable接口，实现run方法： public class MyRunnable implements Runnable{ @Override public void run() { //获取到当前执行该方法的Thread对象 Thread t = Thread.currentThread(); for (int i = 0; i \u0026amp;lt; 100; i++) { System.out.println(\u0026amp;#34;Hello,\u0026amp;#34;+ t.getName()); } } } 实现多线程： public static void main(String[] args) { //1.创建MyRunnable对象 MyRunnable myRunnable = new MyRunnable(); //2.利用MyRunnable对象创建Thread对象 Thread t1 = new Thread(myRunnable); Thread t2 = new Thread(myRunnable); t1.setName(\u0026amp;#34;线 …","date": "2025-10-16 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1760659200",
    "permalink": "/post/set%E5%92%8Cmap%E7%9A%84%E9%81%8D%E5%8E%86/",
    "title": "Set和Map的遍历","content": " Set和Map的遍历 1. Set的遍历 遍历set并将其复制给新的数组ret\nint[] ret = new int[n]; int cnt=0; Iterator\u0026lt;Integer\u0026gt; iterator = set.iterator(); while(iterator.hasNext()) { ret[cnt++] = iterator.next();//next()：获取下一个值 } 2. Map的遍历 for(Map.Entry\u0026lt;Integer,Integer\u0026gt; entry : map.entrySet()) { ret[cnt++] = entry.getValue(); } ","date": "2025-10-16 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1757980800",
    "permalink": "/post/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/",
    "title": "Java定时任务的实现","content": " Java定时任务的实现 1. @Scheduled注解 引入依赖 \u0026amp;lt;!-- Spring Boot Schedule依赖 --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; 使用方法 首先，在定时任务方法所在的类加上 @Component 注解\n接着，在实现定时任务的方法上加上 @Scheduled 注解\nDemoScheduler.java：\n@Component // 标记为Spring组件，使其被扫描并管理 public class DemoScheduler { // 日期格式化工具 private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\u0026amp;#34;yyyy-MM-dd HH:mm:ss\u0026amp;#34;); /** * 示例1：固定延迟执行 * 上一次任务执行完毕后，延迟固定时间再执行下一次 */ @Scheduled(fixedDelay = 5000) // 单位：毫秒，即5秒 public void scheduleTaskWithFixedDelay() { System.out.println(\u0026amp;#34;固定延迟任务执行时间: \u0026amp;#34; + dateFormat.format(new Date())); System.out.println(\u0026amp;#34;这是一个固定延迟执行的任务（上一次执行完毕后5秒再次执行）\u0026amp;#34;); } } 最后，在启动类加上 @EnableScheduling 表示启用定时任务\nTimerApplication.java：\n// @SpringBootApplication 注解标记这是一个Spring Boot应用 // @EnableScheduling 注解启用定时任务功能 @SpringBootApplication @EnableScheduling public class TimerApplication { // 启动Spring Boot应用 // …","date": "2025-09-15 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1752105600",
    "permalink": "/post/%E4%BD%BF%E7%94%A8idea%E7%9A%84maven%E5%AF%BC%E5%87%BAjar%E5%8C%85%E5%A4%B1%E8%B4%A5/",
    "title": "使用IDEA的Maven导出jar包失败","content": " 使用IDEA的Maven导出jar包失败 错误还原：项目使用的是jdk1.8，先使用maven的Lifecycle中的clean，再package，当使用package时，报错：[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project cinema-manage-system: Fatal error compiling: java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does\n原因：maven识别的是环境变量的jdk版本（21），而项目使用的是jdk1.8\n作法：将在系统变量中，设置环境变量JAVA_HOME为java1.8的路径(D:/jdks/jdk1.8)，虽然此时在cmd中使用命令 Java -version的结果仍然为jdk21,但是maven识别的是环境变量中的版本，没影响\n结果：成功使用package导出jar包\n","date": "2025-07-09 17:00:00",
    "updated": "2025-11-25 16:46:00"
  }, 
  {
    "objectID": "1750809600",
    "permalink": "/post/%E4%BD%BF%E7%94%A8git%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%E6%95%99%E7%A8%8B/",
    "title": "使用Git贡献代码教程","content": " 使用Git贡献代码教程 前言 git适用于GitHub、Gitee、GitLab等主流托管平台，它们均使用git作为底层版本控制工具\nGit中的三个分区 Git有三个主要的工作区域：工作区（working directory）、暂存区（staging area）和版本库（repository）。 工作区是指您电脑文件系统上用于修改文件的目录。在这里，您可以创建、编辑和删除文件。 暂存区是一个中间状态，它充当了您提交更改的缓冲区。在Git中，您必须明确地将文件添加到暂存区，然后才能将其提交到版本库中。这样做的好处是，您可以对每个更改进行精细控制，并确保只提交需要保存的更改。 版本库包含Git存储库的所有历史记录和元数据。它是Git存储库的核心组成部分，是由Git自动维护的。 简而言之，工作区是您正在处理的实际文件，而暂存区是下一次提交所需更改的文件列表。它们之间的区别在于，您可以对工作区中的任何文件进行修改，但只有将它们添加到暂存区并将其提交到版本库中，它们才会成为Git跟踪的部分。\n1.配置用户信息 在最开始使用git之前，需要先配置git的用户信息：\ngit config --global user.name \u0026amp;#34;这里输入你的用户名\u0026amp;#34; git config --global user.email \u0026amp;#34;这里输入你的邮箱\u0026amp;#34; 其中，用户名可自定义，其作用是用于标识提交者的身份，不一定与GitHub、Gitee、GitLab等平台的用户名一致 配置完之后，可以看一下配置信息：\ngit config --global --list 2.克隆项目到本地 在本地新建文件夹(如本地文件夹名称为my_project)，接着使用自己fork仓库的地址克隆项目到本地(如项目文件夹名称为project)：\ngit clone 你的fork仓库地址.git 克隆成功之后，变可在本地文件夹my_project中发现有克隆下来的项目文件夹project\n3.切换分支 注意，之后的操作都要在项目的文件夹中进行，否则会报错。在本地文件夹my_project中使用命令以进入：\ncd project 选择需要将项目上传的分支，如此时想把修改之后的内容上传到feature分支：\ngit checkout feature 出现如下的提示则说明切换分支成功：\nbranch …","date": "2025-06-24 17:00:00",
    "updated": "2025-06-25 16:46:00"
  }, 
  {
    "objectID": "1749331560",
    "permalink": "/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/",
    "title": "服务器项目部署","content": " 服务器项目部署 1. 内网穿透 1.1 目的 为了让他人也能通过指定的url访问到自己启动的项目\n1.2 实现步骤 1.2.1 下载与配置 搜索 https://www.cpolar.com ，进入cpolar官网。\n注册账号。\n注册登录之后，按照首页的提示进行安装和配置。\n获取Authtoken ：点击首页右上角的 “用户设置”——\u0026amp;gt;点击 “重置Authtoken” ——\u0026amp;gt;复制Authtoken进行配置。\n配置Authtoken：按下 win+R ，在cmd命令行中复制如下命令：\ncpolar authtoken (这里改为你自己的Authtoken) 出现如下类似的结果说明配置成功：\n启动cpolar：以管理员的身份运行cmd ，输入如下命令：\nnet start cpolar 出现结果，说明已经启动成功：\n1.2.2 使用Cpolar 通过地址 http://127.0.0.1:9200 （或者点击桌面的图标）访问cpolar的管理界面，输入注册时的邮箱与密码即可访问：\n点击 隧道管理 ——\u0026amp;gt; 创建隧道 ，即可实现本地地址与穿透地址的映射\n1.2.3 示例 在vscode自己写一个cpolar.html文件：\n\u0026amp;lt;!DOCTYPE html\u0026amp;gt; \u0026amp;lt;html lang=\u0026amp;#34;en\u0026amp;#34;\u0026amp;gt; \u0026amp;lt;head\u0026amp;gt; \u0026amp;lt;meta charset=\u0026amp;#34;UTF-8\u0026amp;#34;\u0026amp;gt; \u0026amp;lt;meta name=\u0026amp;#34;viewport\u0026amp;#34; content=\u0026amp;#34;width=device-width, initial-scale=1.0\u0026amp;#34;\u0026amp;gt; \u0026amp;lt;title\u0026amp;gt;Document\u0026amp;lt;/title\u0026amp;gt; \u0026amp;lt;/head\u0026amp;gt; \u0026amp;lt;body\u0026amp;gt; \u0026amp;lt;h1\u0026amp;gt;Hello Cpolar!\u0026amp;lt;/h1\u0026amp;gt; \u0026amp;lt;/body\u0026amp;gt; \u0026amp;lt;/html\u0026amp;gt; 利用 Live Server 插件，右键点击 Open With Live Server，即可运行\n运行之后，可以看到此时我的html文件的的本地端口号为5500（不同的设备可能不一样）\n记下该端口号，在刚刚的 创建隧道 页面中的 本地地址部分 输入为5500端口号，并选择 随机域名 和 http 协议 …","date": "2025-06-07 14:26:00",
    "updated": "2025-06-07 15:26:00"
  }, 
  {
    "objectID": "1747703160",
    "permalink": "/post/likesystem/",
    "title": "亿级流量点赞系统","content": " 仓库地址：https://github.com/meeting77smile/like-system 项目介绍： 本人在学习高并发项目过程中制作的亿级流量点赞系统，包含了后端代码。 项目亮点： 高并发优化​​：设计Caffeine+Redis多级缓存架构，高并发情况下的接口响应时间降低92%（压测TPS达3000+）；利用HeavyKeeper热点探测算法将本地缓存命中率提升至92% 异步处理系统：集成Pulsar消息队列实现批量消费（1000条/10秒），数据库写压力下降94%；通过Lua脚本保证原子操作+定时对账，数据一致性达99.99% 分布式架构升级​​：从MySQL迁移至TiDB实现自动分片，写入吞吐量提升2倍 高可用保障​​：搭建Prometheus+Grafana监控平台，故障定位效率提升70%，便于项目维护 ","date": "2025-05-19 18:06:00",
    "updated": "2025-05-23 06:00:00"
  }, 
  {
    "objectID": "1747098360",
    "permalink": "/post/nebulamall/",
    "title": "星云好物——基于微服务架构的电商平台","content": " 仓库地址：https://github.com/meeting77smile/nebula-mall 项目介绍： 本人在学习微服务过程中制作的电商平台的后端代码。 项目亮点： 服务间异步调用​​：利用RabbitMQ结合SpringAMQP代替OpenFeign从而实现服务间的异步调用，实现了降低服务间的耦合性、避免级联失败的效果。 超时订单取消：通过DelayExchange插件，利用延迟消息实现订单超时取消功能。 负载均衡：基于Nacos注册中心，利用DiscoveryClient和随机负载均衡算法，实现服务调用的负载均衡。 网关登录校验：通过自定义GlobalFilter，结合JWT工具实现一个登录校验的过滤器，提高安全性和拓展性。 微服务保护：利用Sentinel实现请求限流、线程隔离和服务熔断，通过Prometheus+Grafana监控平台可知系统可用性达99.9%。 ","date": "2025-05-12 18:06:00",
    "updated": "2025-05-23 06:00:00"
  }, 
  {
    "objectID": "1743987960",
    "permalink": "/post/secondkill/",
    "title": "电商秒杀项目","content": " 仓库地址：https://github.com/meeting77smile/SecondKill 项目介绍： 本人在学习高并发过程中制作的百万级别秒杀系统，包含了前端和后端代码。 项目亮点： 通过redis预减+使用RabbitMQ处理订单请求，用户下单时的QPS提升接近4倍； 通过redis执行lua脚本，避免库存超卖； 通过生成uuid隐藏秒杀地址、easy-captcha生成验证码和计数器算法实现接口限流等操作，实现了防止恶意刷单的功能，从而增加了系统的抗压能力。 ","date": "2025-04-06 18:06:00",
    "updated": "2025-05-23 06:00:00"
  }, 
  {
    "objectID": "1742101860",
    "permalink": "/post/jiyuguidebook/",
    "title": "积语——云伴学","content": " 仓库地址 网页端：https://github.com/meeting77smile/JiYuLearning 移动端：https://github.com/meeting77smile/JiYuLearning-APP 使用指南 欢迎使用积语·云伴学——基于多智能体的个性化学习规划辅助定制平台\n本 指南 旨在帮助您快速了解并高效利用该学习助手，它具有完备且实用的功能，无论是进行日常学习、能力进阶还是知识拓展，它都将是您不可或缺的伙伴。积语·云伴学具有移动端和网页端双平台，以下是详细的使用指南：\n移动端 一、登录注册 打开app后，输入账号与密码即可完成登入。 若为首次使用，则需要进入注册页面，注册一个新账户（注意：每个用户之间账号不可重复，用户名允许重复）。在注册时，需要输入您的高等数学水平，数字1、2、3分别代表水平”较低“、”一般“、”较高“，若不填则默认为1，填入您的水平我们才能更好地为您提供个性化定制服务\n登录完成之后，即可进入在主界面，之后您就可以在主界面通过点击不同的按钮来使用相应的功能了。\n二、查看/修改个人信息 若您想修改用户名、用户水平等信息，便可点击主界面的”账号信息“按钮进入相应的页面修改相应的信息。每次修改不需要将每项信息都修改，修改全部或部分的信息之后，点击”保存更改“按钮之后即可完成更改。 每日刷题 点击”每日刷题“按钮即可进入相应界面进行题目的练习，系统会根据您实际的情况为您分配不同的题目。\n例如，当您的水平较低时，会为您分配较为简单的题目：\n当您水平较高时，会为您分配具有挑战性的题目：\n完成练习之后，点击”提交“按钮，系统将为您进行判分，并将您的作答情况记录在后台系统中，便于大模型利用您的学习情况进行个性化分析。\n三、智能问答 点击”智能问答“按钮，即可进入该界面。根据您水平及详细情况的不同，人工智能助手”积语“将给出具有针对性的回答。如：\n当您的水平较高：\n当您的水平为“中等”时：\n您不仅可以询问积语有关题目的问题，还可以让积语根据您的学习情况为您定制学习路线，学累了也能找积语谈谈心放松一下噢~\n积语的深度思考需要时间，故请停留在对话界面耐心等待回答。\n四、事项规划 点击按钮，首先您会进入事项列表界面。在该界面中，点击”请选择时间“或者左右滑动屏幕，便可查看不同时间的待做事项。界面底部展示了当日已完成、未完成的事项以及完成今日所 …","date": "2025-03-15 22:11:00",
    "updated": "2025-05-23 13:53:00"
  }, 
  {
    "objectID": "1732388040",
    "permalink": "/post/android_notes/",
    "title": "Android笔记","content": " 安卓基础 学习前的声明 1. 语言要求 本次学习用到的语言为Java。（Kotlin虽然为Android官方推荐语言，但Java与Kotlin的关系类似于C与C++的关系，学好了Java，便能比较快地上手Kotlin） 2. 设置主界面 在AndroidManifest.xml文件中，在如图所示的位置改为想要作为主界面的的java文件名（注意别忘了名称开头要加点）\n注意：若需要运行多个界面，若程序会跳转到多个界面，则也应该将需要运行的多个Activity的java文件名写在AndroidManifest . xml文件中。\n3. Java代码的说明 注意：实例中所给的代码最好别全部复制，需要看清代码的内容再选择进行复制。\n图中所示代码上方的类名\u0026amp;quot;ButtonStyleActivity\u0026amp;quot;与Java文件名相同，读者在复制代码时需将其改为自己的对应的Java文件名。\nsetContentView中的R指的是resource（资源），图中的activity_button_style是layout文件夹里的xml文件的文件名（注意：xml文件的文件名一般都为小写），其含义是将该xml文件设置为该Java文件的布局，读者在复制代码时也应该将其改为自己的xml文件名；\n类似的，findViewById指的是通过id获得该视图，所以一般在xml文件中为视图定义了变量之后，若想在Java文件中使用，就需要用findViewById函数。图中tv_result = findViewById(R.id.tv_result) 语句中，左边的tv_result是在Java文件中的变量名，类型为TextView（由于示例图片中其被设置为了全局变量，故类型省略），右边的tv_result是xml文件中给视图组件定义的id。（注意：二者名称不一定得相同，只是此时为了易于识别才采取了相同的变量名）。\n4. 修改虚拟机的底部导航栏 首先将在虚拟机的桌面中下滑，即可找到设置选项：\n接着在搜索中输入Button navigation\n最后在所给的几种类型中选择想要的底部导航类型\n5. 新建Moule(模块) 一个Moule可简单理解为一个应用，在左侧栏显示为一个文件夹，如图中划线部分即为一个Module：\n新建方法:\n首先，点击此处，并选择\u0026amp;quot;project\u0026amp;quot;：\n接 …","date": "2024-11-23 11:54:00",
    "updated": "2025-05-23 11:00:00"
  }, 
  {
    "objectID": "1730524260",
    "permalink": "/post/html5+css3%E5%85%A5%E9%97%A8/",
    "title": "HTML5+CSS3入门","content": " HTML5+CSS3 1. 基础知识 1.1 网页的相关概念 网站：指在因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的网页集合。\n网页：是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，一般是以.htm或.html后缀结尾的文件，因此将其俗称为HTML文件。\n1.2 Web标准 为什么要使用Web标准：不同的浏览器显示或者排版会有差异，为了可以让开发人员写出的页面更标准、更统一，因此需要一个统一的标准\n构成：主要包括结构（Structure)、表现（Presentation）和行为（Behavior）三个方面。结构类似身体、表现类似外观装饰、行为类似动作，三者中结构最重要。\n不同构成的说明：结构用于对网页元素进行整理和分类，一般写在HTML文件里；表现用于设置网页元素的版式、颜色、大小等外观形式，一般写在CSS文件里；行为是指网页模型的定义及交互的编写，现阶段写在JavaScript文件 里。\n1.3 VSCode常用快捷键 shift+alt+下箭头(上箭头）：快速将一行代码复制到下一行。\nctrl+d:选定多个相同的单词。先双击选定一个单词，然后按下ctrl+d再松开可以依次往下选择相同的单词，这样同样修改相同的单词就非常方便。\nctrl+h:全局替换某单词。先按下ctrl+h，再输入需要全局替换的单词，再点击“全部替换”。\n如：将“body”全部换为“b“：\nctrl+g：快速定位到某一行。先按下ctrl+g，再输入需要定位到的行数，再按下回车即可。\nshift+alt+拖动鼠标:选中一个代码区块。\n此快捷键可避免只用拖动鼠标时选中空格部分：\n自定义快捷键：\n首先，点击”管理“\n其次，点击”键盘快捷方式”\n接着，打字输入想要更改的快捷键：\n点击需要更改的快捷键，再按照一定次序按下想要更改成的按键（注意：此时是按键盘上的按键，而不是打字输入），即可完成快捷键的更改。\n1.4 VSCode在网页中显示运行结果 首先，在VSCode的“扩展”中搜索“Live Server”插件并安装：\n安装完后，当代码写完时，右键点击鼠标，再点击”Open with Live Sever“即可在浏览器中看到运行结果。\n1.5 常用插件 HTML Boilerplate\n下载后输入html，选 …","date": "2024-11-01 22:11:00",
    "updated": "2025-05-23 13:37:00"
  }]